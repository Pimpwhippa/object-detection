071019
coco14grand

14 coco classes plus the rest =33 classes

use the same number of training images and same numbers of labels from traintry3, or maybe traintry4 if result is good
but in label files
delete_label = [1,4,5,...,78,79]
awk {if $1 isin delete_label}; delete that line

then reindex car to 1, bird, cat, dog to 4,5,6, backpack,handbag,suitcase to 7,8,9 etc.
99 to 33


1
4
5
6
7
8
9
10
11
12
13
17
18
19
20
21
22
23
25
27
29
30
31
32
33
34
35
36
37
38
39
40
41
42
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
64
65
66
68
69
70
71
72
73
74
75
77
78
79

while read -r line 
do
    echo $line
    sed -i "/$line/d" .
done < ../traingrandyolo/classes_to_delete.txt


Assuming the line numbers to be deleted are in a file to-be-deleted and the data is in big-data-file, then, using Bash process substitution:

 sed -f <(sed 's/$/d/' to-be-deleted) big-data-file > smaller-data-file
The inner sed 's/$/d' command converts the line numbers into sed delete operations. The outer sed commands reads the delete commands and applies the operations to the big data file.


Jonathan Leffler
596k9999 gold badges719719 silver badges1075

delete_label = [1,4,5,...,78,79]

for file in train2014label14;
while read -r line 
do
    echo $line
    sed -i "/$line/d" delete_label.txt
done

loop and while cannot be together

sed -i '\|a.b.c.d/24|d' file

awk {if $1 isin delete_label}; delete that line

$ awk -F'[ ,]' 'FNR==NR{a[$1];next} !($4 in a)' toremove.txt users.txt 
username, userid, sidebar_side, sidebar_colour
"John Lennon", 90123412, "left", "blue"
"George Harrison", 72349482, "left", "green"

bad_words = ['bad', 'naughty']

with open('oldfile.txt') as oldfile, open('newfile.txt', 'w') as newfile:
    for line in oldfile:
        if not any(bad_word in line for bad_word in bad_words):
            newfile.write(line)




for f in *.txt; do  awk '{print; $1 = 9997; print}' "$f"; done

for f in *.txt; while read -r line;do echo $line sed -i "/$line/d" delete_label.txt; done


tmp=$(mktemp)
while IFS= read -r file; do
    awk '{print} $1==8852{$1=9997; print}' "$file" > "$tmp" &&
    mv "$tmp" "$file"
done < <(find . -maxdepth 2 -mindepth 2) )
rm -f "$tmp"

tmp=$(mktemp)
while IFS= read -r file; do
    awk '$1==8852{$1=9997; print}' "$file" > "$tmp" &&
    mv "$tmp" "$file"
done < ../traingrandyolo/classes_to_delete.txt
rm -f "$tmp"

3 methods
sed
open and write
awk

finally should use thisssssssssssssssss i think
make a list into a pattern
and then print what's not in list

LIST=$(cat list.txt | tr "\n" "|")
and then use @randomir 's answer

awk -v pat=$LIST '$0~pat {n=2}; n {n--; next}; 1' birthdays

var='hello123'
awk -F: -v pattern="$var" '$2 !~ pattern' input.txt > output.txt

for file in .;
do
to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|")
awk -F: -v pattern="$to_delete" '$1 !~ pattern' file > "$file".txt
done

tmp=$(mktemp)
while IFS= read -r file; 
do
to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|")
awk -F: -v pattern="$to_delete" '$1 !~ pattern' "$file" > "$tmp" &&
mv "$tmp" "$file"
done < <(find . -maxdepth 1 -mindepth 1)
rm -f "$tmp"


root@3bd6b6e7921c:/objectstodetect/train2014label14# while IFS= read -r file;  do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F: -v pattern="$to_delete" '$1 !~ pattern' "$file" > "$tmp" && mv "$tmp" "$file"; done < find -maxdepth 1 -mindepth 1
bash: syntax error near unexpected token `-maxdepth'

while IFS= read -r file;  do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F: -v pattern="$to_delete" '$1 !~ pattern' "$file" > "$tmp" && mv "$tmp" "$file"; done < find . -type f
bash: syntax error near unexpected token `.'


gives no error but deletes everything
for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F"/t" -v pattern="$to_delete" '$1 !~ pattern' "$file" > "$file"; done
nano COCO_train2014_000000000086.txt


for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F"/t" -v pattern="$to_delete" '$1 !~ pattern {print}' "$file" > "$file"; done


for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F"/t" -v pattern="$to_delete" '$1 !~ /pattern/ {print}' "$file" >
"$file"; done

has to use tmp otherwise it deletes everything
have to use = otherwise all the number stays anyway

for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); awk -F"/t" -v pattern="$to_delete" '$1 != /pattern/' "$file" > "$tmp" && mv "$tmp" "$file"; done


sed -i 's/2/1/g' *

sed -i 's/3/2/g' *
sed -i 's/14/3/g' *
sed -i 's/15/4/g' *
sed -i 's/16/5/g' *
sed -i 's/24/6/g' *
sed -i 's/26/7/g' *
sed -i 's/28/8/g' *


sed -i 's/43/9/g' *
sed -i 's/62/10/g' *
sed -i 's/63/11/g' *
sed -i 's/67/12/g' *
sed -i 's/76/13/g' *


sed -i 's/80/14/g' *
sed -i 's/81/15/g' *
sed -i 's/82/16/g' *
sed -i 's/83/17/g *
sed -i 's/84/18/g' *
sed -i 's/85/19/g' *
sed -i 's/86/20/g' *
sed -i 's/87/21/g' *
sed -i 's/88/22/g' *
sed -i 's/89/23/g' *
sed -i 's/90/24/g' *

sed -i 's/91/25/g' *
sed -i 's/92/26/g' *
sed -i 's/93/27/g' *
sed -i 's/94/28/g' *
sed -i 's/95/29/g' *
sed -i 's/96/30/g' *
sed -i 's/97/31/g' *
sed -i 's/98/32/g' *

I came up with this awk to confirm the grep

awk '
FILENAME == ARGV[1] {to_remove[$1]=1; next}
! ($5 in to_remove) {print}' file1 file2

for file in *.txt; do
awk '
FILENAME == ARGV[1] {to_delete[$1]=1; next}
! ($1 in to_delete) {print}' "$file" "$tmp" && mv "$tmp" "$file"; done

sed -n -i '/^Hey:hello123$/!p'  filename

for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); sed -n -i -v pattern="$to_delete" '/^pattern/!p' "$file" > "$tmp" && mv "$tmp" "$file"; done

for file in *.txt; do to_delete=$(cat ../traingrandyolo/classes_to_delete.txt | tr "\n" "|"); sed -n -i '/$to_delete/!p' "$file"; done



for file in *.txt; do egrep -f ../traingrandyolo/classes_to_delete.txt "$file" > "$tmp" && mv "$tmp" "$file"; done

















